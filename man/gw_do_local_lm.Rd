% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gw_regr_functions.R
\name{gw_do_local_lm}
\alias{gw_do_local_lm}
\title{Undertakes a single weighted regression}
\usage{
gw_do_local_lm(w, formula, data)
}
\arguments{
\item{w}{A vector of weights with length equal to the number of observations in data.}

\item{formula}{A formula to be used in the regression, with terms contained in the variables names of the input data.}

\item{data}{A flat data table in data.frame, matrix or tibble format}
}
\value{
A vector of coefficient estimates in the order Intercept, Variable 1, Variable 2, etc
}
\description{
Returns the local GWR coefficients for a given bandwidth. This is usually run after the optimal bandwidth has been determined, within the gw_regr function and not as a standalone function.
}
\examples{
library(sf)
# load data and define a model formula
data(georgia)
formula = as.formula(MedInc ~ PctBach + PctEld)
##  1. how the function works
# define a distance matrix, a location and an adaptive bandwidth
dist_mat = as.matrix(dist(st_coordinates(st_centroid(georgia)), upper = T, diag = T))
obs_index = 70
bw = 30
# create the nearby function - see the help for `gw_get_nearby` in the gw_ package
nearby_func = gw_get_nearby(adaptive = TRUE)
# apply to get an index of locations and get a vector of distances
index = nearby_func(obs_index, dist_mat, bw)
dists = dist_mat[obs_index,index]
# create the weighting function and weight the nearby locations 
#  - see the help for `gw_get_weight` in the gw_ package
weight_func = gw_get_weight(kernel = "bisquare", adaptive = TRUE)
# apply the weight function to the distances and extend to a vector of length observations
w = weight_func(bw, dists)
w_vec = rep(0, nrow(georgia))
w_vec[index] = w
# extract the coefficients for this location
gw_do_local_lm(w_vec, formula, georgia)
## 2. Using the function operationally

}
